// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.DIRECTIVEOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.DIRECTIVEOPEN)
            {
                ParseDirective(node); // NonTerminal Rule: Directive
            tok = scanner.LookAhead(TokenType.DIRECTIVEOPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER); // ZeroOrMore Rule
            while (tok.Type == TokenType.SQUAREOPEN
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseExtProduction(node); // NonTerminal Rule: ExtProduction
            tok = scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseDirective(ParseNode parent) // NonTerminalSymbol: Directive
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Directive), "Directive");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DIRECTIVEOPEN); // Terminal Rule: DIRECTIVEOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DIRECTIVEOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVEOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER); // ZeroOrMore Rule
            while (tok.Type == TokenType.IDENTIFIER)
            {
                ParseNameValue(node); // NonTerminal Rule: NameValue
            tok = scanner.LookAhead(TokenType.IDENTIFIER); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.DIRECTIVECLOSE); // Terminal Rule: DIRECTIVECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DIRECTIVECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Directive

        private void ParseNameValue(ParseNode parent) // NonTerminalSymbol: NameValue
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NameValue), "NameValue");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.ASSIGN); // Terminal Rule: ASSIGN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: NameValue

        private void ParseExtProduction(ParseNode parent) // NonTerminalSymbol: ExtProduction
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExtProduction), "ExtProduction");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.SQUAREOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.SQUAREOPEN)
            {
                ParseAttribute(node); // NonTerminal Rule: Attribute
            tok = scanner.LookAhead(TokenType.SQUAREOPEN); // ZeroOrMore Rule
            }

             // Concat Rule
            ParseProduction(node); // NonTerminal Rule: Production

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ExtProduction

        private void ParseAttribute(ParseNode parent) // NonTerminalSymbol: Attribute
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Attribute), "Attribute");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SQUAREOPEN); // Terminal Rule: SQUAREOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUAREOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX); // Option Rule
                if (tok.Type == TokenType.INTEGER
                    || tok.Type == TokenType.DOUBLE
                    || tok.Type == TokenType.STRING
                    || tok.Type == TokenType.HEX)
                {
                    ParseParams(node); // NonTerminal Rule: Params
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.SQUARECLOSE); // Terminal Rule: SQUARECLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SQUARECLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Attribute

        private void ParseParams(ParseNode parent) // NonTerminalSymbol: Params
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Params), "Params");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseParam(node); // NonTerminal Rule: Param

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseParam(node); // NonTerminal Rule: Param
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Params

        private void ParseParam(ParseNode parent) // NonTerminalSymbol: Param
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Param), "Param");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.HEX:
                    tok = scanner.Scan(TokenType.HEX); // Terminal Rule: HEX
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.HEX) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Param

        private void ParseProduction(ParseNode parent) // NonTerminalSymbol: Production
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Production), "Production");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.ARROW); // Terminal Rule: ARROW
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ARROW) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseRule(node); // NonTerminal Rule: Rule

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CODEBLOCK, TokenType.SEMICOLON); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.CODEBLOCK:
                    tok = scanner.Scan(TokenType.CODEBLOCK); // Terminal Rule: CODEBLOCK
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CODEBLOCK) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CODEBLOCK.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.SEMICOLON:
                    tok = scanner.Scan(TokenType.SEMICOLON); // Terminal Rule: SEMICOLON
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SEMICOLON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Production

        private void ParseRule(ParseNode parent) // NonTerminalSymbol: Rule
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Rule), "Rule");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRING, TokenType.IDENTIFIER, TokenType.BRACKETOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                case TokenType.BRACKETOPEN:
                    ParseSubrule(node); // NonTerminal Rule: Subrule
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Rule

        private void ParseSubrule(ParseNode parent) // NonTerminalSymbol: Subrule
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Subrule), "Subrule");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseConcatRule(node); // NonTerminal Rule: ConcatRule

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PIPE); // ZeroOrMore Rule
            while (tok.Type == TokenType.PIPE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PIPE); // Terminal Rule: PIPE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PIPE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PIPE.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseConcatRule(node); // NonTerminal Rule: ConcatRule
            tok = scanner.LookAhead(TokenType.PIPE); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Subrule

        private void ParseConcatRule(ParseNode parent) // NonTerminalSymbol: ConcatRule
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ConcatRule), "ConcatRule");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseSymbol(node); // NonTerminal Rule: Symbol
                tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN); // OneOrMore Rule
            } while (tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.BRACKETOPEN); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ConcatRule

        private void ParseSymbol(ParseNode parent) // NonTerminalSymbol: Symbol
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Symbol), "Symbol");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.BRACKETOPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    ParseSubrule(node); // NonTerminal Rule: Subrule

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.LookAhead(TokenType.UNARYOPER); // Option Rule
            if (tok.Type == TokenType.UNARYOPER)
            {
                tok = scanner.Scan(TokenType.UNARYOPER); // Terminal Rule: UNARYOPER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNARYOPER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYOPER.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Symbol


    }

    #endregion Parser
}
